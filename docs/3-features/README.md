# Outpost Features

- [Multi-Tenant Support](#multi-tenant-support)
- [Event Topics and Topic-Based Subscriptions](#event-topics-and-topic-based-subscriptions)
- [Publish Events](#publish-events)
- [Event Delivery](#event-delivery)
- [User Alerts](#user-alerts)
- [Tenant User Portal](#tenant-user-portal)
- [Configurable Log Levels](#configurable-log-levels)
- [OpenTelemetry](#opentelemetry)
- [Hookdeck Telemetry](#hookdeck-telemetry)

## Multi-Tenant Support

Create multiple tenants on a single Outpost deployment.

TODO

## Event Topics and Topic-Based Subscriptions

Outpost supports the common publish and subscription paradigm to ease adoption and integration into existing systems.

TODO

### Event fanout

A message is sent to a topic is replicated and sent to multiple endpoints. This allows for parallel processing and asynchronous event notifications.

TODO

## Publish Events

Events can be published in one of two ways: to a pre-established message bus queue or by making an HTTP request to the Publish API.

Using the message bus queue allows for a higher publishing guarantee since there are no other dependencies than the message bus, and you may already be publishing events requiring minimal change on your end. However, since the control plane may need to create copies of the event (for each destination), events must be requested in the control plane manage queue, therefore incurring higher costs.

Using the Publishing API allows you to avoid implementing publishing to your service bus. It removes and reduces the initial publishing cost, but it adds the burden of ensuring the Publish API is highly available and does not run out of resources.

The events need to follow the given structure:

```json
{
  "id": "123", // Optional but recommended. If left empty, ID will be generated by hashing the topic, data and timestamp
  "tenant_id": "12345",
  "destination_id": "12345", // Optional. Used to force delivery to a specific destination
  "topic": "something.created", // Optional. Assumed to match ANY topic if left empty.
  "eligible_for_retry": false // Optional, default to "false". Control if an event should be retried.
  "time": "2024-06-01 08:23:36.082374Z", // ISO Timestamp of the event
  "metadata": { // Arbitrary key-value mapping for event
    "key": "value" // String, number or boolean
  },
  "data": { // Freeform JSON data
    "hello": "world"
  }
}
```

Each event (without a `destination_id`) is evaluated against all the registered destinations. An event is delivered and logged for each eligible destination. 

The `metadata` is translated to the destination's native metadata, for instance, with Webhooks and HTTP headers. The published data will be the full event if the destination does not support metadata.

## Event Delivery

1. **Event destination types**: Out of the box support for Webhooks, Hookdeck Event Gateway, Amazon EventBridge, AWS SQS, AWS SNS. GCP Pub/Sub, RabbitMQ, and Kafka. Extend to support other destinations types.
2. **Automatic and manual retries**: Configure retry strategies for event destinations and manually trigger event delivery retries via the API or user portal.
3. **At least once delivery guarantee**: Messages are guaranteed to be delivered at least once and never lost.
4. **Webhook best practices**: Opt-out webhook best practices, such as headers for idempotency, timestamp and signature, and signature rotation.

TODO

### Event Destination Types

Destinations must be asynchronous and not run any business logic to be eligible. Multiple “Event Gateways” and message buses are supported at release.

- Webhooks
- Hookdeck Event Gateway
- AWS SQS
- AWS EventBridge
- GCP PubSub
- RabbitMQ
- Kafka

<details>
<summary>Future Roadmap</summary>

- Azure EventGrid
- Azure Service Bus
- MQTT
- Segment & other CDPs
- Zapier & other no code tools
- S3 API
</details>

### Getting Destination Types

Destinations can be registered either through the tenant-facing portal or with the API. When using the API, you need to build your own UI to capture user input on the destination configuration. Since each destination requires a specific configuration, the `GET /destination-types` endpoint provides a JSON schema for each destination type.

For example, for the `webhook` type:

```json
  {
    "type": "webhook",
    "label": "Webhook",
    "description": "Send event via an HTTP POST request to a URL of your choice",
    "icon": "<svg />",
    "instructions": "Some *markdown*",
    "remote_setup_url": null,
    "config_fields": [
      {
        "type": "text",
        "label": "URL",
        "description": "The URL to send the event to",
        "validation": "/((([A-Za-z]{3,9}:(?://)?)(?:[-;:&=+$,w]+@)?[A-Za-z0-9.-]+(:[0-9]+)?|(?:www.|[-;:&=+$,w]+@)[A-Za-z0-9.-]+)((?:/[+~%/.w-_]*)???(?:[-+=&;%@.w_]*)#?(?:[w]*))?)/",
        "required": true
      }
    ],
    "credential_fields": []
  }
```

`config_fields` `Field[]`

Config fields are non-secret values that can be stored and displayed to the user in plain text.

`credential_fields` `Field[]` 

Credential fields are secret values that will be AES encrypted and obfuscated to the user. Some credentials may not be obfuscated, it’s the destination type that dictated the obfuscation logic.

`instructions` `string`

Some destinations will require instructions to configure. For instance, with Pubsub, the user will need to create a service account and grant some permissions to that service account. The string is a markdown string to be rendered with any markdown rendering library. Images will be hosted through the GitHub repository. 

`remote_setup_url`

Some destinations may have Oauth flow or other managed-setup flow that can be triggered with a link. If a `remote_setup_url` is set then the user should be prompted to follow the link to configure the destination.

We will provide recommended UI patterns and wireframes for implementation in your own app.

## User Alerts

Alerts are triggered when an event fails to deliver to a destination. The `ALERT_DEBOUNCING_INTERVAL_SECOND` variable can configure alerting behaviour. The debouncing interval represents the amount of time that needs to elapse for a new alert to be triggered. Alerts are scoped per destination.

Alerts support 2 types of triggers by consecutive failures or by failure rate. Destinations can be auto-disabled when the trigger is reached using the `ALERT_AUTO_DISABLE_DESTINATION` config.

Instead of implementing user-facing alerting, alerts are produced on a callback URL configured through the `ALERT_CALLBACK_URL` variable. The server does not respond with a 200 there will be an exponential backoff and log the failure. Authentication is handled using the Admin API Key via a bearer token.

It’s your responsibility to format and deliver the alert to your tenant using your existing notification system.

<details>
<summary>Future roadmap</summary>

- Support publishing the event to a MQ instead of via a HTTP callback url
</details>

### Consecutive failure alerts

 `ALERT_CONSECUTIVE_FAILURE_COUNT` variable will alert when the consecutive failure count reaches 50%, 70%, 90% and 100%. At 100% the destination will be disabled if the config is enabled.

```json
{
  "topic": "alert.consecutive-failure",
  "timestamp": "2024-01-01T00:00:00Z",
  "data": {
    "max_consecutive_failures": 20,
	  "consecutive_failures": 5,
	  "will_disable": true,
	  "destination": DestinationObject,
	  "response": {
	    "status": "500",
	    "data": {
	      "some": "value"
	    }
	  }
  }
}
```

### Failure rate alerts

`ALERT_FAILURE_WINDOW_SECOND` and `ALERT_FAILURE_RATE` can also be used to configured alerts after certain failure rate for a certain amount of time. An alert notification will be triggered at 50%, 70%, 90% and 100% of the `ALERT_FAILURE_WINDOW_SECOND`. At 100% the destination will be disabled if the config is enabled.

```json

{
  "topic": "alert.failure-rate",
  "timestamp": "2024-01-01T00:00:00Z",
  "data": {
    "failure_window_second": 60,
    "duration": 30,
    "max_failure_rate": 0.1,
    "failure_rate": 0.2,
	  "will_disable": true,
	  "destination": DestinationObject,
	  "response": {
	    "status": "500",
	    "data": {
	      "some": "value"
	    }
	  }
  }
}
```

## Tenant User Portal

The tenant can have an optional portal that lets them configure their destination. The portal supports:

- Creating and configuring a destination
- Updating or deleting a destination
- Disable or enable a destination
- Display historical events, event data and responses by status and destinations

The portal is accessed by generating a JWT from the `GET` `/:tenant_id/portal` endpoint, which returns a redirect URL with a JWT token in the URL. When the user is redirected, the JWT persists in their session storage and is used as the credential for the duration of the session.

When the portal is used the API needs to be publicly exposed to the public internet.

The portal is a React SPA that’s distributed via the API.

### Theming

The portal supports both light and dark mode which case be set through the `?theme` query param when redirecting to the portal. The portal can also be “forced” into a specific theme using the `PORTAL_FORCE_THEME` config.

Additionally the portal can be customized with a option logo either with a URL or base64 encoded 64.

The `PORTAL_ACCENT_COLOR` can also be used to change the primary color.

### Required Config

`PORTAL_REFERER_URL`  is used to redirect the user when the JWT token is expired on when the user clicks “back”

`ORGANIZATION_NAME` is used to display the name of the organization deploying the portal

### Design

See the [designing an event destinations dashboard guide](#) for more information.

## Configurable Log Levels

The Outpost services will produce stdout logs based on the configured `LOG_LEVEL`. Regardless of the log level, some audit logs may need to be retained for compliance. The `AUDIT_LOG` variable can enable the production of relevant auditing logs irrespective of the `LOG_LEVEL`, such as API calls, published events, and outbound network calls.

## OpenTelemetry

OpenTelemetry supports the service's key performance metrics. You need to bring your own OpenTelemetry target for the metrics to be produced and exported. These metrics are all exported in the form of [histograms](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#histogram). Supported metrics are:

### `delivery_latency` 

Delivery latency to the destination. Dimensions: `type` `tenant` `destination_id`

### `delivery_error_rate`

The error rate of the message delivered. `type` `tenant` `destination_id`

### `delivered_events`

The number of delivered events. `type` `tenant` `destination_id` `status`

### `published_events`

The number of published events. `topic` `tenant`

### `eligible_events`

The number of published events that matched at least one destination. `topic` `tenant`

### `api_response_latency` 

The API response latency. `endpoint` `method` `path` `tenant`

### `api_calls`

The number of API calls. `endpoint` `method` `path` `tenant`

## Hookdeck Telemetry

The service will report anonymous usage statistics and errors to a Hookdeck endpoint for service improvement and bug fixes. Telemetry can be disabled with the `DISABLE_TELEMETRY` config.